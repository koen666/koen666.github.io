{
    "version": "https://jsonfeed.org/version/1",
    "title": "木语 • All posts by \"docker\" tag",
    "description": "Spark!",
    "home_page_url": "https://koen666.github.io",
    "items": [
        {
            "id": "https://koen666.github.io/2026/01/15/udocker/",
            "url": "https://koen666.github.io/2026/01/15/udocker/",
            "title": "让你在没有 root 权限的机子上跑镜像",
            "date_published": "2026-01-14T16:00:00.000Z",
            "content_html": "<h2 id=\"背景为什么我们需要它\"><a class=\"anchor\" href=\"#背景为什么我们需要它\">#</a> 背景：为什么我们需要它？</h2>\n<p>在科研和开发过程中，我们经常遇到这样的死结：</p>\n<ol>\n<li><strong>环境依赖地狱</strong>：代码依赖特定的 CUDA 版本、Ubuntu 版本或一大堆 Python 库，手动配置极易冲突。</li>\n<li><strong>没有 Root 权限</strong>：实验室的服务器、学校的 HPC 集群通常由管理员统一管理，普通学生账户没有 <code>sudo</code> 权限。</li>\n<li><strong>Docker 无法使用</strong>：标准的 Docker 需要守护进程（Daemon）以 root 身份运行，没有权限意味着 <code>docker: command not found</code> 或 <code>permission denied</code>。</li>\n</ol>\n<p>虽然 <strong>Podman</strong> 是一个很好的无 Root 替代品，但它对 Linux 内核版本有要求（需要 User Namespaces 支持），且在某些老旧的超算系统上仍然难以安装。</p>\n<p>这时候，<strong>udocker</strong> 就是一个非常实用的解决方案。</p>\n<h2 id=\"什么是-udocker\"><a class=\"anchor\" href=\"#什么是-udocker\">#</a> 什么是 udocker？</h2>\n<p><code>udocker</code> 是一个专门为在用户空间运行 Docker 容器而设计的工具：</p>\n<ul>\n<li><strong>纯用户空间</strong>：不需要 root 权限，也不需要安装系统级守护进程。</li>\n<li><strong>兼容性强</strong>：本质上是一个 Python 脚本，几乎可以在任何 Linux 发行版（CentOS 6/7、Ubuntu、Fedora 等）上运行。</li>\n<li><strong>原理</strong>：通过 <strong>PRoot</strong>（利用 <code>ptrace</code> 机制）或 <strong>Fakechroot</strong> 等技术，模拟 root 环境和文件系统挂载，让容器“以为”自己运行在特权环境中。</li>\n</ul>\n<p>一句话总结：<strong>只要你能跑 Python，就能跑 udocker，进而跑 Docker 镜像。</strong></p>\n<h2 id=\"1-安装-udocker\"><a class=\"anchor\" href=\"#1-安装-udocker\">#</a> 1. 安装 udocker</h2>\n<p>安装过程很简单：下载脚本并初始化。</p>\n<h3 id=\"11-下载-udocker-脚本\"><a class=\"anchor\" href=\"#11-下载-udocker-脚本\">#</a> 1.1 下载 udocker 脚本</h3>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">curl</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> -L</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> https://raw.githubusercontent.com/indigo-dc/udocker/master/udocker.py</span><span style=\"color:#AB5959;--shiki-dark:#CB7676\"> </span><span style=\"color:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> udocker</span></span></code></pre>\n<h3 id=\"12-赋予执行权限\"><a class=\"anchor\" href=\"#12-赋予执行权限\">#</a> 1.2 赋予执行权限</h3>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">chmod</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> +x</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> udocker</span></span></code></pre>\n<h3 id=\"13-移动到你的-bin-目录可选\"><a class=\"anchor\" href=\"#13-移动到你的-bin-目录可选\">#</a> 1.3 移动到你的 bin 目录（可选）</h3>\n<p>前提：<code>~/.local/bin</code> 已在 <code>PATH</code> 中。</p>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">mv</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> ~/.local/bin/</span></span></code></pre>\n<h3 id=\"14-初始化\"><a class=\"anchor\" href=\"#14-初始化\">#</a> 1.4 初始化</h3>\n<p>这会自动下载所需的引擎二进制文件到 <code>~/.udocker</code> 目录。</p>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> install</span></span></code></pre>\n<h3 id=\"15-验证安装\"><a class=\"anchor\" href=\"#15-验证安装\">#</a> 1.5 验证安装</h3>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> version</span></span></code></pre>\n<h2 id=\"2-基本使用像-docker-一样操作\"><a class=\"anchor\" href=\"#2-基本使用像-docker-一样操作\">#</a> 2. 基本使用：像 Docker 一样操作</h2>\n<p>udocker 的命令设计上尽量模仿 Docker，但有一个关键区别：<strong>udocker 严格区分“容器创建”和“容器运行”。</strong></p>\n<h3 id=\"21-拉取镜像pull\"><a class=\"anchor\" href=\"#21-拉取镜像pull\">#</a> 2.1 拉取镜像（pull）</h3>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\"># 拉取 PyTorch 镜像</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> pull</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> pytorch/pytorch:1.13.0-cuda11.6-cudnn8-runtime</span></span></code></pre>\n<h3 id=\"22-创建容器create\"><a class=\"anchor\" href=\"#22-创建容器create\">#</a> 2.2 创建容器（create）</h3>\n<p>在 Docker 中，<code>docker run</code> 常同时完成创建和启动；在 udocker 中，更推荐先显式创建容器。</p>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\"># 从镜像创建一个名为 \"my_experiment\" 的容器</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> create</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> --name=my_experiment</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> pytorch/pytorch:1.13.0-cuda11.6-cudnn8-runtime</span></span></code></pre>\n<h3 id=\"23-运行容器run\"><a class=\"anchor\" href=\"#23-运行容器run\">#</a> 2.3 运行容器（run）</h3>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\"># 运行容器并进入交互式终端</span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\"># -v 挂载目录：将宿主机当前目录挂载到容器的 /workspace</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> run</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> -v</span><span style=\"color:#B5695977;--shiki-dark:#C98A7D77\"> \"</span><span style=\"color:#999999;--shiki-dark:#666666\">$(</span><span style=\"color:#998418;--shiki-dark:#B8A965\">pwd</span><span style=\"color:#999999;--shiki-dark:#666666\">)</span><span style=\"color:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\">:/workspace</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> my_experiment</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> /bin/bash</span></span></code></pre>\n<p>进入容器后，你会看到自己是 root（容器内部视角）。你可以 <code>apt-get install</code> 或 <code>pip install</code>，但这些改动只影响容器文件系统，不会影响宿主机。</p>\n<h2 id=\"3-进阶技巧科研场景专用\"><a class=\"anchor\" href=\"#3-进阶技巧科研场景专用\">#</a> 3. 进阶技巧：科研场景专用</h2>\n<h3 id=\"31-启用-gpu-支持nvidia\"><a class=\"anchor\" href=\"#31-启用-gpu-支持nvidia\">#</a> 3.1 启用 GPU 支持（NVIDIA）</h3>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\"># 使用 --nvidia 标志启用 GPU 支持</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> run</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> --nvidia</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> my_experiment</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> nvidia-smi</span></span></code></pre>\n<p>注意：udocker <strong>不包含</strong>驱动程序，它只是将宿主机的 <code>/dev/nvidia*</code> 设备和相关库映射进容器。请确保宿主机已正确安装显卡驱动。</p>\n<h3 id=\"32-更改运行模式execmode\"><a class=\"anchor\" href=\"#32-更改运行模式execmode\">#</a> 3.2 更改运行模式（execmode）</h3>\n<p>如果遇到 <code>Segmentation fault</code> 或某些程序跑不起来，可以尝试更改执行模式。udocker 提供多种模式（不同版本的可用项可能略有差异）：</p>\n<ul>\n<li><strong>P1/P2（PRoot）</strong>：默认模式，兼容性最好，但 I/O 密集任务可能有性能损耗。</li>\n<li><strong>F1/F2/F3（Fakechroot）</strong>：性能更好，但兼容性可能稍差。</li>\n<li><strong>R1（RunC）</strong>：若内核/环境满足条件，性能接近原生 Docker。</li>\n</ul>\n<p>查看当前模式：</p>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> setup</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> --execmode</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> my_experiment</span></span></code></pre>\n<p>切换为某个模式（示例：F3）：</p>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> setup</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> --execmode=F3</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> my_experiment</span></span></code></pre>\n<h2 id=\"4-常见问题与局限\"><a class=\"anchor\" href=\"#4-常见问题与局限\">#</a> 4. 常见问题与局限</h2>\n<h3 id=\"41-端口映射\"><a class=\"anchor\" href=\"#41-端口映射\">#</a> 4.1 端口映射</h3>\n<p>udocker 默认使用宿主机网络栈（Host Mode）。因此通常不能像 Docker 那样用 <code>-p 8080:80</code> 做 NAT 端口转发。</p>\n<ul>\n<li>如果容器内服务监听 <code>8000</code>，它往往就是在宿主机的 <code>8000</code> 上监听。</li>\n</ul>\n<h3 id=\"42-安全性\"><a class=\"anchor\" href=\"#42-安全性\">#</a> 4.2 安全性</h3>\n<p>udocker 的目标偏向“可用性”，而不是强隔离。不要在容器里运行不可信/恶意代码，因为它可能影响当前用户可访问的文件（例如你的 <code>HOME</code> 目录）。</p>\n<h3 id=\"43-清理与空间占用\"><a class=\"anchor\" href=\"#43-清理与空间占用\">#</a> 4.3 清理与空间占用</h3>\n<p>容器文件默认存储在 <code>~/.udocker/containers</code> 下，不用的容器/镜像建议定期清理：</p>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\"># 删除容器</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> rm</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> my_experiment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\"># 删除镜像（按实际 tag 替换）</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">udocker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> rmi</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> pytorch/pytorch:xxxx</span></span></code></pre>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>在受限的服务器或 HPC 环境下，udocker 可以在<strong>无需 root 权限</strong>的前提下运行容器化环境，适合解决“在别人的机器上跑我的环境”这一类问题。</p>\n<p>如果你在集群上装不上 Docker，又想复用 Docker Hub 上现成镜像，可以优先试试 udocker。</p>\n",
            "tags": [
                "docker",
                "images",
                "hpc",
                "tutorial"
            ]
        },
        {
            "id": "https://koen666.github.io/2025/07/26/docker-basic-usage/",
            "url": "https://koen666.github.io/2025/07/26/docker-basic-usage/",
            "title": "Docker 基本使用教程",
            "date_published": "2025-07-26T00:53:34.303Z",
            "content_html": "<blockquote>\n<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>\n</blockquote>\n<hr />\n<h2 id=\"一-docker的用途\"><a class=\"anchor\" href=\"#一-docker的用途\">#</a> 一、Docker的用途</h2>\n<p>Docker 的主要用途，目前有三大类。</p>\n<ol>\n<li>\n<p>提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>\n</li>\n<li>\n<p>提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>\n</li>\n<li>\n<p>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>\n</li>\n</ol>\n<hr />\n<h2 id=\"二-验证是否安装成功\"><a class=\"anchor\" href=\"#二-验证是否安装成功\">#</a> 二、验证是否安装成功</h2>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> version</span></span></code></pre>\n<hr />\n<h2 id=\"三-image文件\"><a class=\"anchor\" href=\"#三-image文件\">#</a> 三、Image文件</h2>\n<p>Docker 把应用程序及其依赖，打包在 <strong>image 文件</strong>里面。只有通过这个文件，才能生成 Docker 容器。<br />\nimage 文件可以看作是容器的模板，Docker 根据 image 文件生成容器的实例。<br />\n同一个 image 文件，可以生成多个同时运行的容器实例。</p>\n<p>image 是一个 <strong>二进制文件</strong>。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。<br />\n举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你自己的 image。</p>\n<h3 id=\"列出本机的所有-image-文件\"><a class=\"anchor\" href=\"#列出本机的所有-image-文件\">#</a> 列出本机的所有 image 文件</h3>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">$</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> image</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> ls</span></span></code></pre>\n<h4 id=\"️-删除-image-文件\"><a class=\"anchor\" href=\"#️-删除-image-文件\">#</a> 🗑️ 删除 image 文件</h4>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">$</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> image</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> rm</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\"> </span><span style=\"color:#2993a3;--shiki-dark:#5eaab5\">[</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\">imageName</span><span style=\"color:#2993a3;--shiki-dark:#5eaab5\">]</span></span></code></pre>\n<p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。</p>\n<p>一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。<br />\n即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p>\n<h3 id=\"镜像仓库image-repository\"><a class=\"anchor\" href=\"#镜像仓库image-repository\">#</a> 镜像仓库（Image Repository）</h3>\n<p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。</p>\n<ul>\n<li>Docker 的官方仓库 <strong>Docker Hub</strong> 是最重要、最常用的 image 仓库。</li>\n<li>此外，你也可以使用国内的镜像仓库（如阿里云、腾讯云）或者搭建私有仓库。</li>\n<li>出售自己制作的 image 文件也是可以的。</li>\n</ul>\n<h3 id=\"imagecontainer\"><a class=\"anchor\" href=\"#imagecontainer\">#</a> image&amp;&amp;container</h3>\n<p>容器是镜像跑起来的实例，一个镜像可以有多个容器</p>\n<hr />\n<h2 id=\"四-如何跑起来呢\"><a class=\"anchor\" href=\"#四-如何跑起来呢\">#</a> 四、如何跑起来呢</h2>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> image</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> pull</span><span style=\"color:#AB5959;--shiki-dark:#CB7676\"> </span><span style=\"color:#AB5959;--shiki-dark:#CB7676\">&#x3C;</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\">projec</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\">t</span><span style=\"color:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">       #将image文件从仓库抓取到本地</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> container</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> run</span><span style=\"color:#AB5959;--shiki-dark:#CB7676\"> </span><span style=\"color:#AB5959;--shiki-dark:#CB7676\">&#x3C;</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\">projec</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\">t</span><span style=\"color:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">    #将image文件在你的电脑上跑起来，新建容器</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> container</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> start</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\"> </span><span style=\"color:#2993a3;--shiki-dark:#5eaab5\">[</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\">ID</span><span style=\"color:#2993a3;--shiki-dark:#5eaab5\">]</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\">       </span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">#将已有的容器跑起来</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> container</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> kill</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\"> </span><span style=\"color:#2993a3;--shiki-dark:#5eaab5\">[</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\">ID</span><span style=\"color:#2993a3;--shiki-dark:#5eaab5\">]</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\">        </span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">#手动终止容器的运行</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> container</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> ls</span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">               #在你电脑上正在跑起来的容器</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> container</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> ls</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> -all</span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">          #列出本机所有容器，包括终止运行的容器</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> container</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> rm</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\"> </span><span style=\"color:#2993a3;--shiki-dark:#5eaab5\">[</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\">containerID</span><span style=\"color:#2993a3;--shiki-dark:#5eaab5\">]</span><span style=\"color:#393A34;--shiki-dark:#DBD7CAEE\"> </span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">#删除停止运行的容器，防止占用硬盘空间</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> exec</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> -it</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> my-nginx</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> bash</span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">     #在叫my-nginx的容器内，开启一个bash命令终端进去操作</span></span></code></pre>\n<h2 id=\"注意docker-container-run命令具有自动抓取-image-文件的功能-如果发现本地没有指定的-image-文件就会从仓库自动抓取-因此前面的docker-image-pull命令并不是必需的步骤\"><a class=\"anchor\" href=\"#注意docker-container-run命令具有自动抓取-image-文件的功能-如果发现本地没有指定的-image-文件就会从仓库自动抓取-因此前面的docker-image-pull命令并不是必需的步骤\">#</a> 注意，docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的docker image pull命令并不是必需的步骤。</h2>\n<h2 id=\"五-常见参数\"><a class=\"anchor\" href=\"#五-常见参数\">#</a> 五、常见参数</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全称</th>\n<th style=\"text-align:left\">作用</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-d</code></td>\n<td style=\"text-align:left\"><code>--detach</code></td>\n<td style=\"text-align:left\">后台运行容器</td>\n<td style=\"text-align:left\"><code>docker run -d nginx</code></td>\n<td style=\"text-align:left\">容器启动后，终端不会附加到容器的输入/输出，返回一个容器ID。这是运行后台服务（如Web服务器、数据库）的标准模式。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-p</code></td>\n<td style=\"text-align:left\"><code>--publish</code></td>\n<td style=\"text-align:left\">映射容器端口到主机端口</td>\n<td style=\"text-align:left\"><code>docker run -p 8080:80 nginx</code></td>\n<td style=\"text-align:left\">格式为 <code>-p &lt;主机端口&gt;:&lt;容器端口&gt;</code>。将容器内部的端口暴露给主机，从而可以从外部访问容器内的服务。示例中将容器的80端口映射到主机的8080端口，通过 <code>http://localhost:8080</code> 即可访问Nginx。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-v</code></td>\n<td style=\"text-align:left\"><code>--volume</code></td>\n<td style=\"text-align:left\">挂载数据卷</td>\n<td style=\"text-align:left\"><code>docker run -v /host/data:/container/data app</code></td>\n<td style=\"text-align:left\">格式为 <code>-v &lt;主机路径&gt;:&lt;容器路径&gt;</code>。用于在主机和容器之间共享数据或持久化容器内的数据。即使容器被删除，主机上的数据仍然存在。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-e</code></td>\n<td style=\"text-align:left\"><code>--env</code></td>\n<td style=\"text-align:left\">设置环境变量</td>\n<td style=\"text-align:left\"><code>docker run -e MY_VAR=value -e DB_HOST=db app</code></td>\n<td style=\"text-align:left\">向容器内部传递配置信息，如数据库连接字符串、密码、运行模式等。应用程序在容器内可以通过读取这些环境变量来改变其行为。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>--name</code></td>\n<td style=\"text-align:left\"><code>--name</code></td>\n<td style=\"text-align:left\">为容器指定一个名称</td>\n<td style=\"text-align:left\"><code>docker run --name my_nginx nginx</code></td>\n<td style=\"text-align:left\">为创建的容器赋予一个易读的唯一名称，方便后续的管理（如启动、停止、查看日志），而不必使用冗长且难记的容器ID。</td>\n</tr>\n</tbody>\n</table>\n<p>一个典型的 <code>docker run</code> 命令会组合使用这些参数来定义一个功能完整的容器：</p>\n<pre class=\"shiki shiki-themes vitesse-light vitesse-dark\" style=\"background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee\" tabindex=\"0\"><code class=\"language-bash\"><span class=\"line\"><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\"># 运行一个名为 'my-web-app' 的 WordPress 容器</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">docker</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> run</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> -d</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> \\ </span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">                   # 在后台运行</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">  --name</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> my-web-app</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> \\ </span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">             # 容器命名为 my-web-app</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">  -p</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> 8080:80</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> \\ </span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">                    # 将主机的8080端口映射到容器的80端口</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">  -e</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> WORDPRESS_DB_HOST=db:3306</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> \\ </span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">  # 设置环境变量：数据库地址</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">  -e</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> WORDPRESS_DB_USER=root</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> \\ </span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">     # 设置环境变量：数据库用户</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">  -e</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> WORDPRESS_DB_PASSWORD=secret</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> \\#</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> 设置环境变量：数据库密码</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">  -v</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> wordpress_data:/var/www/html</span><span style=\"color:#A65E2B;--shiki-dark:#C99076\"> \\#</span><span style=\"color:#B56959;--shiki-dark:#C98A7D\"> 挂载命名卷，持久化网站数据</span></span>\n<span class=\"line\"><span style=\"color:#59873A;--shiki-dark:#80A665\">  wordpress:latest</span><span style=\"color:#A0ADA0;--shiki-dark:#758575DD\">                 # 使用的镜像</span></span></code></pre>\n<h3 id=\"其他常用参数补充\"><a class=\"anchor\" href=\"#其他常用参数补充\">#</a> 其他常用参数补充</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">全称</th>\n<th style=\"text-align:left\">作用</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-it</code></td>\n<td style=\"text-align:left\"><code>--interactive</code> + <code>--tty</code></td>\n<td style=\"text-align:left\">以交互模式运行容器</td>\n<td style=\"text-align:left\"><code>docker run -it ubuntu /bin/bash</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>--rm</code></td>\n<td style=\"text-align:left\"><code>--rm</code></td>\n<td style=\"text-align:left\">容器退出时自动清理</td>\n<td style=\"text-align:left\"><code>docker run --rm alpine echo &quot;hello&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-u</code></td>\n<td style=\"text-align:left\"><code>--user</code></td>\n<td style=\"text-align:left\">指定运行容器的用户</td>\n<td style=\"text-align:left\"><code>docker run -u 1000 myapp</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>--network</code></td>\n<td style=\"text-align:left\"><code>--network</code></td>\n<td style=\"text-align:left\">将容器连接到指定网络</td>\n<td style=\"text-align:left\"><code>docker run --network my_net nginx</code></td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "container",
                "docker",
                "learn",
                "linux",
                "virtual"
            ]
        }
    ]
}